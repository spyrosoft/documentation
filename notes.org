* Navigation

** Page Down
   C-v

** Page Up
   M-v

** Move to top/bottom of buffer
   M-< / M->

** Return to Previous Mark
   C-u C-<SPC>

** Go to line
   M-g g

** Move page text to middle/top/bottom
   C-l

** Move page text heuristically around - similar to C-l
   C-S-l

** Move point to middle/top/bottom
   M-r

** Jump to matching delimiter
   C-M-n
   C-M-p

** Forward one sentence
   M-e

** Backward one sentence
   M-a

** Forward one paragraph (or element)
   M-}

** Backward one paragraph (or element)
   M-{

** Set horizontal column navigation jump (semipermanent goal column)
   C-x C-n

** Remove semipermanent goal column
   C-u C-x C-n


* Marks and Regions

** Set a mark
   C-<SPC>

** Jump to current mark
   C-u C-<SPC>

** Swap mark and point
   C-x C-x

** Deactivate mark/region
   C-g

** Set global mark
   C-S-<SPC>

** Shift selection
   S-<ARROW KEY>

** Mark word forwards
   M-@

** Set mark at the end of the following balanced expression
   C-M-@

** Set region around current paragraph
   M-h

** Set region around entire buffer
   C-x h

** Indent region
   C-x <TAB>


* Rectangle Regions
** Set a rectangle mark
   C-x <SPC>

** Kill the rectangle
   C-x r k

** Copy but don't delete the rectangle
   C-x r M-w

** Delete the rectangle but don't copy it
   C-x r d

** Yank the last killed rectangle in the current position of point
   C-x r y

** Use the current rectangle's dimensions to insert spaces to the left of the rectangle (for example, to insert spaces at the beginning of a line of code) (`open-rectangle')
   C-x r o

** Replace the contents of the rectangle with spaces
   C-x r c

** Insert numbered list numbers to the left of the selected rectangle - use C-u for styling & start #
   C-x r N

** Replace contents of rectangle with the specified string on each line
   C-x r t STRING <RET>


* Clipboard
** Cut all text between pointer and mark
   C-w

** Kill to beginning of line
   M-0 C-k

** Kill backward to the beginning of the previous word
   M-<DEL>

** Kill forward to the end of the next word
   M-d

** Add region to kill ring, but don't delete it
   M-w

** Kill through the next occurrence of a character
   M-z CHAR

** After yanking, cycle through the kill ring the text just pasted
   M-y

** Append the next kill command to the previous one
   C-M-w


* Registers
** Store position of point and current buffer in register R (R is any character or number)
   C-x r <SPC> R

** Jump to register R
   C-x r j R

** Copy region into register R (C-u to also delete the region)
   C-x r s R

** Copy the region-rectangle into register R (C-u to also delete rectangle)
   C-x r r R

** Insert content from register R (C-u to place point after inserted text and mark at beginning)
   C-x r i R

** Append or prepend contents of region to register R
   M-x append-to-register <RET> R
   M-x prepend-to-register <RET> R

** Save the state of all windows in the current frame to register R
   C-x r w R

** Save the state of all windows and frames to register R
   C-x r f R

** Restore window/frame configuration from register R (Same as jump to stored cursor position) (C-u to delete existing frames/windows)
   C-x r j R

** Store a number into register R (Used for incrementing numbers during macro execution) (NUMBER is optional - defaults to 0)
   C-u NUMBER C-x r n R

** Increment the contents of register R by NUMBER amount (NUMBER is optional - defaults to 1)
   C-u NUMBER C-x r + R


* Bookmarks
** Add bookmark named current filename
   C-x r m <RET>

** List all bookmarks
   C-x r l

** Jump to the bookmark named BOOKMARK
   C-x r b BOOKMARK <RET>

** Review bookmark commands
   C-x r l C-h m

** Saves current position of all default bookmarks (Needed if opening a different emacs session)
   M-x bookmark-save

** Save and load context specific bookmark files
   M-x bookmark write <RET> FILENAME <RET>
   M-x bookmark load <RET> FILENAME <RET>


* Search and Replace

** Search
   C-s (also search again for the last serch term - regex included)

** Reverse Search
   C-r

** Search and Replace (C-u to go backwards)
   M-%

** Edit current search term (M-f when finished)
   M-e

** Regex search
   C-M-s
   C-M-r

** Cycle through previous searches
   M-n
   M-p

** Find all instances of a search and list them by lines (visit line with <RET> - press e to edit lines & C-c C-c to return again)
   M-s o
   M-x occur
   M-x multi-occur (for multiple buffers)

** Count the occurances of a regex
   M-x how-many

** Search for a newline
   C-j

** Append the word following point to the current search
   C-w

** Append the rest of the line following point to the current search (converts to lower to remain case insensitive)
   M-s C-e

** Search for variable or function name (also works after entering incremental search & toggles)
   M-s _

** Search for variable or function name at point
   M-s .

** Search for words ignoring spaces and punctuation
   M-s w

** Delete lines which match regex
   M-x flush-lines
   M-x keep-lines (the opposite)


* Undo/Redo

** Undo
   C-/

** Undo changes within region
   C-u C-/


* Macros

** Execute a command multiple times
   C-u command

** Execute the same keystroke multiple times (for example add 40 dashes)
   M-4 0 -

** Start Recording Macro
   f3
   C-x (

** Stop Recording Macro
   f4
   C-x )

** Play Macro
   f4
   C-x e (during macro definition, this exits the definition and executes it immediately - subsequent e strokes each execute the macro again)

** Play Macro Until No More
   C-u 0 C-x e

** Execute macro and append additional keystrokes
   C-u f3

** Do not execute macro - only append additional keystrokes
   C-u C-u f3

** Edit the last defined macro
   C-x C-k C-e

** Edit the currently selected macro step by step (There are a ton of additional command insertion and replacement commands - see manual)
   C-x C-k <SPC>

** Cycle to next defined macro in ring (chains with the next two commands)
   C-x C-k C-n

** Cycle to previous defined macro in ring (chains)
   C-x C-k C-p

** Execute current head of the defined macro ring (Chains with the previous two commands)
   C-x C-k C-k

** Name the head of the macro ring
   C-x C-k n

** Edit a previously named/command-assigned macro
   C-x C-k e NAME <RET>
   C-x C-k e COMMAND

** Assign most recently defined macro a meta command
   C-x C-k n

** Assign most recently defined macro control command
   C-x C-k b (recommended C-x C-k [0-9A-Z]

** Insert macro counter into buffer and increment
   C-x C-k C-i
   f3 (while recording)

** Set macro counter
   C-x C-k C-c

** Specify format for inserting the macro counter
   C-x C-k C-f

** Add arbitrary number to the macro counter
   C-u # C-x C-k C-a (C-u value is optional - if blank the last macro counter inserted is substituted)

** At any point during the recording of a macro, set a breakpoint
   C-x q (upon execution, C-r enters recursive editing - resume with C-M-c) (C-u enters recursive ediding during the recording process as well)

** Execute macro on all lines in a region
   C-x C-k r

** Store macro in register R
   C-x C-k x R

** Execute macro stored in register R (Same as jump to position)
   C-x r j R

** Save macro to file (and M-x load-file later)
   M-x insert-kbd-macro <RET> MACRONAME <RET>


* Windows/Buffers

** Clear all buffers but this one
   C-x 0

** Close a Buffer
   C-x k

** Switch to a Buffer
   C-x b

** Split vertically
   C-x 3

** Split horizontally
   C-x 2

** Switch to a split
   C-x o


* Minibuffers

** Scroll the content (such as in the help context)
   C-M-v
   M-<PageUp>/<M-PageDown>

** Enter a minibuffer to navigate through the items with the arrow keys
   M-v


* Narrowing

** Narrow down to content between point and mark
   C-x n n

** Widen to entire buffer again
   C-x n w

** Narrow down to current page
   C-x n p

** Narrow down to current defun
   C-x n d


* Editing

** Insert Unicode Character
   C-x 8 <RET> NAME OF UNICODE CHARACTER (autocompletes) <RET>

** Swap two lines
   C-x C-t

** Swap two surrounding words and move forward one
   M-t

** Swap two surrounding characters and move forward one
   C-t

** Insert newline on the next line and keep point where it is
   C-o

** Insert newline without indentation
   C-j

** Remove all but one of many consecutive newlines
   C-x C-o

** Remove all whitespace around point and replace it with a single space
   M-<SPC>

** Remove all whitespace around point
   M-\

** Join current line with previous line excluding tabulation and newline
   M-^


* Case Conversion

** Convert region to Lower Case
   C-x C-l

** Convert region to Upper Case
   C-x C-u

** Convert last word to capital
   M-- M-c

** Convert last word to Lower Case
   M-- M-l

** Convert last word to Upper Case
   M-- M-u


* Files and Directories

** Save a file
   C-x C-s

** Open a file
   C-x C-f

** Open a directory for browsing (don't specify a file name)
   C-x C-f

** Open a file read-only
   C-x C-r

** Open an alternate file (replaces the buffer containing the file found previously)
   C-x C-v

** Open a file in another frame (in gui mode, a separate x window opens, but if you close one, the other closes)
   C-x 5 f

** Open a file and split the frame (default split horizontal/vertical)
   C-x 4 f


* Highlighting

** Highlight all instances of current word
   M-s h .

** Unhighlight all instances of regex (defaults to most recent regex - M-n & M-p to cycle)
   M-s h u REGEX <RET>

** Cycle through highlight faces
   M-n
   M-p

** Highlight entire line containing matching regex
   M-s h l REGEX <RET> FACE <RET>


* Shell Commands

** Change default directory
   M-x cd

** Echo current directory
   M-x pwd

** Environment variables are available in file completion
   /example/$NAMED/environment/variable


* Lisp

** Execute lisp and display the result in the echo area
   M-:


* HELP

** Find in help something that matches a keyword
   C-h a

** Find in help what a specific key sequence does
   C-h k

** Search for variables whose values match the specified pattern
   M-x apropos-value


* Misc

** Display the system time
   M-x display-time
